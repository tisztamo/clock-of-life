window.clock = (function clock() {
    const CLOCK_PERIOD = 11520;
    var life;
    var drawer;
    var setup_pattern;

    const init = function(_life, _drawer, _setup_pattern) {
        life = _life;
        drawer = _drawer;
        setup_pattern = _setup_pattern;
    }

    const forEachCell = function(node, x, y, cb) {
        if (node.population === 0) {
            return;
        }
        if (node.level === 0) {
            cb(x, y);
            return;
        }

        if (node.level == 1) {
            forEachCell(node.nw, x - 1, y - 1, cb);
            forEachCell(node.sw, x - 1, y, cb);
            forEachCell(node.ne, x, y - 1, cb);
            forEachCell(node.se, x, y, cb);
            return;
        }
        var offset = node.level === 1 ? 0 : life.pow2(node.level - 2);

        forEachCell(node.nw, x - offset, y - offset, cb);
        forEachCell(node.sw, x - offset, y + offset, cb);
        forEachCell(node.ne, x + offset, y - offset, cb);
        forEachCell(node.se, x + offset, y + offset, cb);
    }

    const clearHash = function() {
        const bounds = life.get_root_bounds();
        const width = bounds.right - bounds.left + 1;
        const size = (bounds.bottom - bounds.top + 1) * width;
        console.log("Allocating " + size);
        const array = new Uint8Array(size);
        const bottom = bounds.bottom;
        const top = bounds.top;
        const right = bounds.right;
        const left = bounds.left;
        let idx = 0;

        var ts = Date.now();
        forEachCell(life.root, 0, 0, function(x, y) {
            const idx = (y - top) * width + x - left;
            array[idx] = 1;
        });
        /*
        const root = life.root;
        for(let y = bounds.top; y <= bottom; y++)
        {
            let right = bounds.right;
            for(let x = bounds.left; x <= right; x++)
            {
                if (life.node_get_bit(root, x, y)) {
                    array[idx] = 1;
                };
                idx += 1;
            }
        }*/
        var ts1 = Date.now();
        console.log("Read time: " + (ts1 - ts))
        life.clear_pattern();
        life.save_rewind_state();

        idx = 0;
        for(let y = bounds.top; y <= bottom; y++)
        {
            for(let x = left; x <= right; x++)
            {
                if (array[idx] === 1) {
                    life.set_bit(x, y, true);
                }
                idx += 1;
            }
        }
        console.log("Rewrite time: " + (Date.now() - ts1))
    }

    const run = function(update_hud)
    {
        var start;
        var step = 1;
        life.set_step(0);

        var msecs_per_frame = 60000 / (CLOCK_PERIOD / step);
        var frameIdx = 0;
        var goal = 0;
        var last_time = Date.now() - 1;
        var fps = 0;

        var gc_counter = 0;
        var pause = 0;

        function update()
        {
            var time = Date.now();
            var elapsed = time - start;

            if (elapsed >= goal) {
                if (pause > 0) {
                    pause -= 1;
                } else {
                    life.next_generation(true);
                }
                drawer.redraw(life.root);
                fps = 0.99 * fps + 0.01 * (1000 / (time - last_time))
                update_hud(fps);
                frameIdx += 1;
                goal = frameIdx * msecs_per_frame;
                last_time = time;

                if (++gc_counter > 5000) {
                    gc_counter = 0;
                    clearHash();
                    pause = 0;
                    //const rle = formats.generate_rle(life, undefined, ["Generated by copy.sh/life"]);
                    //setup_pattern(rle, "reloaded");
                };
            }

        }

        start = Date.now();
        setInterval(update, 50);
    }
    return {
        init: init,
        run: run
    }
})();